-   在 TypeScript 中，`infer` 是一個關鍵字，用於在條件型別（Conditional Types）中引入型別推斷（Type Inference）。
-   `infer` 允許我們在條件型別的 `true` 分支中推斷出某個型別，並將其賦值給一個型別變數。
-   當我們使用 `infer` 時，它會在條件型別中推斷出一個型別並賦值給一個變數。這個過程同時進行，類似於**_邊宣告邊賦值_**。

# 運作順序

1. 條件檢查：

    - 首先，條件型別會檢查左側的型別是否符合右側的模式。
    - 如果符合，則條件成立；否則條件不成立。

2. 型別推斷：

    - 如果條件成立，`infer` 關鍵字會啟動型別推斷機制，推斷出特定的型別並將其賦值給指定的變數。

3. 返回型別：

    - 根據條件的成立與否，條件型別會返回不同的結果。
    - 當條件成立時，返回推斷出的型別；當條件不成立時，返回另一個指定的型別（通常是 `never`）。
    - 這讓我們返回的型別簡單化，動態化，變數化。

??? info "延伸閱讀"

    `infer` 關鍵字在 TypeScript 中是專門設計用於條件型別（Conditional Types）的，其原因如下：

    1. 型別推斷的上下文：

        * `infer` 關鍵字用於推斷型別，它需要在一個特定的上下文中進行操作。條件型別提供了這樣的上下文，允許我們根據型別檢查結果來推斷型別。
        * 在條件型別中，我們可以檢查一個型別是否符合特定模式，並在符合時推斷出一個新的型別。

    2. 條件型別的結構：

        * 條件型別具有類似於三元運算符的結構：`T extends U ? X : Y`。
        * 這種結構允許我們在條件成立時（`T extends U 為 true`）使用 `infer` 來推斷型別，並在條件不成立時返回另一個型別。

    3. 型別變數的作用域：

        * 在條件型別中使用 `infer` 關鍵字時，推斷出的型別變數（如 `infer R` 中的 `R`）僅在條件型別的 `true` 分支中有效。
        * 這確保了型別推斷變數的作用域是明確且受控的，避免了在其他地方意外地使用或污染這些變數。

---

# 基本用法：

```typescript
type GetReturnType<T> = T extends (...args: any[]) => infer R ? R : never;
```

這段代碼定義了一個泛型型別 `GetReturnType`，用於提取函數的返回值型別。

-   條件型別：

    -   `T extends (...args: any[]) => infer R`：檢查 `T` 是否是一個函數。
    -   `infer R`：如果 `T` 是函數型別，則推斷出返回值型別並賦值給 `R`。

        ??? info "延伸閱讀"

            `(...args: any[])` 是 TypeScript 中的函數型別描述符，表示這個函數可以接受任意數量、任意類型的參數。這樣的寫法允許我們不關心具體的參數，只關心函數的返回值型別。以下是對這段代碼的詳細解釋：

            `(...args: any[])` 表示一個接受任意數量、任意類型參數的函數，並會收集到一個 `any` 陣列中。

            -   `...args` 是剩餘參數語法，表示這個函數可以接受零個或多個參數。
            -   `any[]` 表示這些參數組成一個陣列，並且陣列中的每個元素可以是任意類型。

-   返回型別：

    -   如果 `T` 是函數，則返回 `R`（函數的返回值型別）。
    -   否則，返回 `never`。

## 範例

```typescript
type Example = (a: number, b: string) => boolean;
type Result = GetReturnType<Example>; // 結果是 boolean
```

在這個例子中：

1. `Example` 是一個函數型別，它接受兩個參數：一個 `number` 和一個 `string`，並返回一個 `boolean`。
2. `GetReturnType<Example>` 檢查 `Example` 是否符合 `(...args: any[]) => infer R` 的模式。
    - 是的，`Example` 符合這個模式，因為它是一個函數型別。
3. `infer R` 推斷出 `Example` 的返回值型別 `boolean`，並將其賦值給 `R`。
4. 因此，`GetReturnType<Example>` 的結果是 `boolean`。

---

# 其他用法：

`infer` 可以用於提取各種型別的信息，例如數組元素型別、元組元素型別等。

## 範例 1

```typescript
type ElementType<T> = T extends (infer U)[] ? U : never;
```

這段代碼用於提取數組的元素型別。

-   條件型別：

    -   `T extends (infer U)[]`：檢查 `T` 是否是一個數組。
    -   `infer U`：如果 `T` 是數組型別，則推斷出元素型別並賦值給 `U`。

-   返回型別：

    -   如果 `T` 是數組，則返回 `U`（數組的元素型別）。
    -   否則，返回 `never`。

## 範例 2

```typescript
type First<T extends any[]> = T extends [infer F, ...any[]] ? F : never;
```

這段代碼用於提取元組的第一個元素型別。

-   泛型約束：

    -   `T extends any[]`：這裡使用了泛型約束，表示 `T` 必須是數組（或元組）。`any[]` 包含了普通數組和元組。

-   條件型別：

    -   `T extends [infer F, ...any[]] ? F : never`：這是一個條件型別，用於檢查 `T` 是否符合 `[infer F, ...any[]]` 的模式。
    -   `[infer F, ...any[]]`：這裡使用了剩餘參數語法來匹配元組。`infer F` 用於推斷元組的第一個元素型別，`...any[]` 用於匹配剩餘的元素。

-   型別推斷：

    -   如果 `T` 符合 `[infer F, ...any[]]` 的模式，則條件成立，返回 `F`（元組的第一個元素型別）。
    -   如果 `T` 不符合這個模式，則條件不成立，返回 `never`。

---

# 與其他方法的比較

`infer` 與其他 TypeScript 中的型別操作方法可能會讓人混淆，特別是與 `keyof` 和 `extends` 等關鍵字。這裡簡單比較一下它們的用途和區別：

| **方法**  | **說明**                                                   |
| --------- | ---------------------------------------------------------- |
| `infer`   | 用於在條件型別中進行型別推斷，提取和操作型別中的具體部分。 |
| `keyof`   | 用於獲取某個物件型別的所有鍵，返回這些鍵組成的聯合型別。   |
| `extends` | 用於約束泛型型別或在條件型別中進行型別檢查。               |

